## 多线程原理

多线程之所以能够实现，第一是硬件的功劳，也就是CPU。现代的CPU有一个很重要的特性，就是时间片。每一段获得CPU的代码只能运行一个时间片规定的时间，例如10ms。到时间之后CPU就会把正在运行的代码暂停，然后发生一个中断。这个中断是系统级的事件，只有操作系统能够接手，这样控制权就落到了操作系统手里。

接下来就是操作系统的事情了。线程对操作系统来说就是一段代码+运行时数据（主要是寄存器数据，还有线程中与资源相关的数据，比如打开的文件等）。操作系统会为每个线程保存相关的这些数据，当接收到来自CPU的时间片中断事件时，就会按一定规则从这些线程中选择一个，恢复它的运行时数据，这样CPU就可以继续执行这个线程了。

选择一个合适的线程的过程称为线程调度，最简单的规则是FCFS，也就是按排队的时间先后顺序调度，谁先来排队，下一个就让谁运行。另外还有按优先级、按任务大小等调度策略，以及多种策略的组合等方式。详细的可以去了解一下操作系统的原理。

Java中线程实现主要依赖于操作系统，其本身不进行线程管理。它只是把线程相关的操作进行了封装和抽象，以方便我们使用。例如，Java中的线程可以设置优先级，但如果操作系统本身不支持优先级调度策略，那么为线程设置优先级是没有任何作用的



## iOS线程数量

经测试iOS最多能创建66个线程, 66 = 64 \( 最大名称线线程池大小\) + 主线程+ 一些其他随机non-GCD线程

```
for (int i=1; i<30000; i++) {
 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
 [NSThread sleepForTimeInterval:100000];
 });
}
```

**多线程的并发是用时间片轮转等方法实现的**，iPhone 的 CPU 只有两个核心，所以过多线程同时存在仍然可能会造成对主线程的影响。另外**线程创建、销毁、上下文切换等也会消耗很多 CPU 资源**。有些任务内部会有全局的锁（比如 readme 里提到的 CoreText 绘制时的 CGFont 内部锁），这样增加并发并没有作用，反而会带来诸如 readme 中那样的问题。





## FAQ

**提问：工作线程数是不是设置的越大越好？**

回答：肯定不是的

1）一来服务器CPU核数有限，同时并发的线程数是有限的，1核CPU设置10000个工作线程没有意义

2）线程切换是有开销的，如果线程切换过于频繁，反而会使性能降低

**提问：调用sleep()****函数的时候，线程是否一直占用CPU****？**

回答：不占用，等待时会把CPU让出来，给其他需要CPU资源的线程使用

不止调用sleep()函数，在进行一些阻塞调用，例如网络编程中的**阻塞**accept()【等待客户端连接】和**阻塞**recv()【等待下游回包】也不占用CPU资源

**提问：如果CPU****是单核，设置多线程有意义么，能提高并发性能么？**

回答：即使是单核，使用多线程也是有意义的

1）多线程编码可以让我们的服务/代码更加清晰，有些IO线程收发包，有些Worker线程进行任务处理，有些Timeout线程进行超时检测

2）如果有一个任务一直占用CPU资源在进行计算，那么此时增加线程并不能增加并发，例如这样的一个代码

while(1){ i++; }

该代码一直不停的占用CPU资源进行计算，会使CPU占用率达到100%

3）通常来说，Worker线程一般不会一直占用CPU进行计算，此时即使CPU是单核，增加Worker线程也能够提高并发，因为这个线程在休息的时候，其他的线程可以继续工作