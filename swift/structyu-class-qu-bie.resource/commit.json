{"compress":true,"commitItems":[["1a254d12-668f-4cb0-bbbf-398fafe444a5",1559224612076,"[链接](http://www.cocoachina.com/ios/20190520/26989.html)\n\n\n![](/assets/1558336846445706.png)",[[1559224596306,["he15his@he15hisMacBook15.local",[[1,91,"\n\n"]],[91,91],[92,92]]],[1559224596519,["he15his@he15hisMacBook15.local",[[1,93,"\n"]],[92,92],[93,93]]],[1559224597106,["he15his@he15hisMacBook15.local",[[1,93,"1 结构体的构造函数"]],[93,93],[103,103]]],[1559224601859,["he15his@he15hisMacBook15.local",[[1,104,"\n"]],[103,103],[104,104]]],[1559224602125,["he15his@he15hisMacBook15.local",[[1,104,"　　（1）如果结构体中不写初始化函数，则默认会有一个设置全部参数的构造函数。"]],[104,104],[142,142]]],[1559224606623,["he15his@he15hisMacBook15.local",[[1,143,"\n"]],[142,142],[143,143]]],[1559224606988,["he15his@he15hisMacBook15.local",[[1,143,"　　（2）如果在结构体的构造中，变量设置了默认值。怎结构体会有两个初始化函数，一个是：没有任何参数的函数；一个是含有全部参数的函数。但是初始化函数中不能只为部分变量赋值。要不全部都赋值、要不都不要赋值。"]],[143,143],[244,244]]],[1559224612149,["he15his@he15hisMacBook15.local",[[1,245,"\n"]],[244,244],[245,245]]],[1559224612465,["he15his@he15hisMacBook15.local",[[1,245,"　　（3）如果结构体中定义了初始化方法，则系统默认的含有全部参数的初始化方法将不能在使用"]],[245,245],[289,289]]],[1559224618231,["he15his@he15hisMacBook15.local",[[1,290,"\n"]],[289,289],[290,290]]],[1559224618500,["he15his@he15hisMacBook15.local",[[1,290,"　　（4）如果仍需要用到含有全部参数的初始化方法，则需要在结构体中重新定义该方法"]],[290,290],[330,330]]],[1559224628831,["he15his@he15hisMacBook15.local",[[1,331,"\n"]],[330,330],[331,331]]],[1559224629006,["he15his@he15hisMacBook15.local",[[1,332,"\n"]],[331,331],[332,332]]],[1559224629347,["he15his@he15hisMacBook15.local",[[1,332,"3 结构体是值类型, 赋值相等于是copy\n\n　　在Swift中，Array、Dictionary、Set都是结构体，故它们都是值类型.\n\n　　Int、Float、Double、Bool、String都是结构体。"]],[332,332],[438,438]]],[1559224634407,["he15his@he15hisMacBook15.local",[[1,439,"\n"]],[438,438],[439,439]]],[1559224634590,["he15his@he15hisMacBook15.local",[[1,440,"\n"]],[439,439],[440,440]]],[1559224635051,["he15his@he15hisMacBook15.local",[[1,440," 4 如果要在一个结构体的方法中改变自身的值，需要在方法前面添加mutating关键字"]],[440,440],[483,483]]],[1559224640080,["he15his@he15hisMacBook15.local",[[1,93,"#"],[-1,440," "],[1,441," # "]],[93,93],[96,96]]],[1559224643904,["he15his@he15hisMacBook15.local",[[-1,107,"　　（1）"],[1,112,"*"]],[96,96],[108,108]]],[1559224644168,["he15his@he15hisMacBook15.local",[[1,107," "]],[108,108],[108,108]]],[1559224645574,["he15his@he15hisMacBook15.local",[[-1,107," "]],[108,108],[107,107]]],[1559224646368,["he15his@he15hisMacBook15.local",[[1,108," "]],[108,108],[109,109]]],[1559224648912,["he15his@he15hisMacBook15.local",[[-1,143,"　　（2）"],[1,148,"*"]],[109,109],[144,144]]],[1559224649440,["he15his@he15hisMacBook15.local",[[1,143," "]],[143,143],[144,144]]],[1559224650375,["he15his@he15hisMacBook15.local",[[1,145," "]],[145,145],[146,146]]],[1559224652126,["he15his@he15hisMacBook15.local",[[-1,143," "]],[144,144],[143,143]]],[1559224654278,["he15his@he15hisMacBook15.local",[[-1,242,"　　（3）"]],[242,247],[242,242]]],[1559224655631,["he15his@he15hisMacBook15.local",[[1,242,"* "]],[242,242],[244,244]]],[1559224658231,["he15his@he15hisMacBook15.local",[[-1,284,"　　（4）"]],[284,289],[284,284]]],[1559224659031,["he15his@he15hisMacBook15.local",[[1,284,"* "]],[284,284],[286,286]]],[1559224664544,["he15his@he15hisMacBook15.local",[[1,323,"## "]],[323,323],[326,326]]],[1559224669605,["he15his@he15hisMacBook15.local",[[-1,434," "]],[435,435],[434,434]]],[1559224670742,["he15his@he15hisMacBook15.local",[[1,434,"## "]],[434,434],[437,437]]],[1559224732083,[null,[[1,94,"# "],[-1,105,"　　"],[1,109,"如果"],[-1,141,"　　"],[1,145,"如果"],[-1,240,"　　"],[1,244,"如果"],[-1,282,"　　"],[1,286,"如果"],[-1,321,"3 "],[1,325," 3"],[-1,432," #"]],[94,94],[432,432]]],[1559224732084,[null,[[-1,94,"# "],[1,107,"　　"],[-1,109,"如果"],[1,143,"　　"],[-1,145,"如果"],[1,242,"　　"],[-1,244,"如果"],[1,284,"　　"],[-1,286,"如果"],[1,323,"3 "],[-1,325," 3"],[1,434," #"]],[432,432],[94,94]]],[1559224674445,["he15his@he15hisMacBook15.local",[[-1,395,"\n"]],[395,395],[394,394]]],[1559224677837,["he15his@he15hisMacBook15.local",[[1,395,"\n"]],[394,394],[395,395]]],[1559224682557,["he15his@he15hisMacBook15.local",[[-1,349,"　　"]],[351,351],[349,349]]],[1559224684871,["he15his@he15hisMacBook15.local",[[1,349,"* "]],[349,349],[351,351]]],[1559224687390,["he15his@he15hisMacBook15.local",[[1,398,"* "]],[398,398],[400,400]]],[1559224690149,["he15his@he15hisMacBook15.local",[[-1,396,"　　"]],[398,398],[396,396]]],[1559224795075,[null,[[1,94,"# "],[-1,105,"　　"],[1,109,"如果"],[-1,141,"　　"],[1,145,"如果"],[-1,240,"　　"],[1,244,"如果"],[-1,282,"　　"],[1,286,"如果"],[-1,321,"3 "],[1,325," 3"],[-1,347,"　　"],[1,351,"在S"],[-1,394,"　\n"],[1,398,"In"],[-1,432," #"]],[94,94],[432,432]]],[1559224795075,[null,[[-1,94,"# "],[1,107,"　　"],[-1,109,"如果"],[1,143,"　　"],[-1,145,"如果"],[1,242,"　　"],[-1,244,"如果"],[1,284,"　　"],[-1,286,"如果"],[1,323,"3 "],[-1,325," 3"],[1,349,"　　"],[-1,351,"在S"],[1,396,"　\n"],[-1,398,"In"],[1,434," #"]],[432,432],[94,94]]],[1559224760581,["he15his@he15hisMacBook15.local",[[1,56,"[结构体Struct](https://www.cnblogs.com/muzijie/p/6544435.html)"]],[56,56],[115,115]]]]],["30427835-fafb-4565-8e38-80a019adbd51",1559224879053,"[链接](http://www.cocoachina.com/ios/20190520/26989.html)\n[结构体Struct](https://www.cnblogs.com/muzijie/p/6544435.html)\n\n![](/assets/1558336846445706.png)\n\n## 1 结构体的构造函数\n* 如果结构体中不写初始化函数，则默认会有一个设置全部参数的构造函数。\n* 如果在结构体的构造中，变量设置了默认值。怎结构体会有两个初始化函数，一个是：没有任何参数的函数；一个是含有全部参数的函数。但是初始化函数中不能只为部分变量赋值。要不全部都赋值、要不都不要赋值。\n* 如果结构体中定义了初始化方法，则系统默认的含有全部参数的初始化方法将不能在使用\n* 如果仍需要用到含有全部参数的初始化方法，则需要在结构体中重新定义该方法\n\n## 3 结构体是值类型, 赋值相等于是copy\n\n* 在Swift中，Array、Dictionary、Set都是结构体，故它们都是值类型.\n\n* Int、Float、Double、Bool、String都是结构体。\n\n## 4 如果要在一个结构体的方法中改变自身的值，需要在方法前面添加mutating关键字\n",[[1559224877107,["he15his@he15hisMacBook15.local",[[1,117,"\n"]],[116,116],[117,117]]],[1559224877722,["he15his@he15hisMacBook15.local",[[1,117,"##### Struct与Class的共性\n\n1.  定义属性以存储值\n2.  定义提供功能的方法\n3.  使用下标语法定义下标以提供对其值的访问\n4.  定义初始化程序以设置其初始状态\n5.  扩展到超出默认实现范围的功能\n6.  符合协议以提供某种标准功能\n\n##### Struct与Class的区别\n\n1.  Class 是引用类型, Struct是值类型\n2.  内存管理的方式不同, 结构体可以被直接持有及访问, 结构体不会被引用,只会被复制,而类的实例只能通过引用间接访问。\n3.  使用类,可以通过继承来共享代码,而结构体不能被继承\n\n作者：PenName\n链接：https://juejin.im/post/5ad45b56f265da238926316a\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[117,117],[495,495]]],[1559224886923,["he15his@he15hisMacBook15.local",[[-1,393,"作者：PenName\n链接：https://juejin.im/post/5ad45b56f265da238926316a\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[392,495],[393,393]]],[1559224931557,["he15his@he15hisMacBook15.local",[[-1,68,"https://www.cnblogs.com/muzijie/p/6544435.html"]],[69,114],[68,68]]],[1559224932137,["he15his@he15hisMacBook15.local",[[1,68,"[https://juejin.im/post/5ad45b56f265da238926316a](https://juejin.im/post/5ad45b56f265da238926316a)"]],[68,68],[166,166]]],[1559224934452,["he15his@he15hisMacBook15.local",[[-1,68,"[https://juejin.im/post/5ad45b56f265da238926316a](https://juejin.im/post/5ad45b56f265da238926316a)"]],[166,166],[68,68]]],[1559224938939,["he15his@he15hisMacBook15.local",[[-1,56,"[结构体Struct]()"]],[56,69],[56,56]]],[1559224939349,["he15his@he15hisMacBook15.local",[[1,56,"[https://juejin.im/post/5ad45b56f265da238926316a](https://juejin.im/post/5ad45b56f265da238926316a)"]],[56,56],[154,154]]],[1559224958979,["he15his@he15hisMacBook15.local",[[-1,57,"https://juejin.im/post/5ad45b56f265da238926316a"]],[58,104],[57,57]]],[1559224959280,["he15his@he15hisMacBook15.local",[[1,57,"# 结构体与类"]],[57,57],[64,64]]],[1559224961851,["he15his@he15hisMacBook15.local",[[-1,57,"# "]],[59,59],[57,57]]],[1559224979515,["he15his@he15hisMacBook15.local",[[-1,426,"## 1 结构体的构造函数\n* 如果结构体中不写初始化函数，则默认会有一个设置全部参数的构造函数。\n* 如果在结构体的构造中，变量设置了默认值。怎结构体会有两个初始化函数，一个是：没有任何参数的函数；一个是含有全部参数的函数。但是初始化函数中不能只为部分变量赋值。要不全部都赋值、要不都不要赋值。\n* 如果结构体中定义了初始化方法，则系统默认的含有全部参数的初始化方法将不能在使用\n* 如果仍需要用到含有全部参数的初始化方法，则需要在结构体中重新定义该方法\n\n## 3 结构体是值类型, 赋值相等于是copy\n\n* 在Swift中，Array、Dictionary、Set都是结构体，故它们都是值类型.\n\n* Int、Float、Double、Bool、String都是结构体。\n\n## 4 如果要在一个结构体的方法中改变自身的值，需要在方法前面添加mutating关键字\n"]],[425,812],[425,425]]],[1559224980403,["he15his@he15hisMacBook15.local",[[1,426,"\n"]],[425,425],[426,426]]],[1559224982202,["he15his@he15hisMacBook15.local",[[1,427,"\n"]],[426,426],[427,427]]],[1559224983832,["he15his@he15hisMacBook15.local",[[1,427,"#### 关于初始化的差别\n\n##### Struct的初始化\n\n*   Memberwise Initializers : Struct 会根据它所拥有的变量自带一个默认的初始化方法,我们将这个称谓Memberwise Initializers"]],[427,427],[550,550]]],[1559224992819,["he15his@he15hisMacBook15.local",[[1,551,"\n"]],[550,550],[551,551]]],[1559224993165,["he15his@he15hisMacBook15.local",[[1,551,"*   Default initializer: 通过给每一个属性默认值来完成初始化,但必须是每个属性都必须有默认值"]],[551,551],[609,609]]],[1559224998066,["he15his@he15hisMacBook15.local",[[1,610,"\n"]],[609,609],[610,610]]],[1559224998407,["he15his@he15hisMacBook15.local",[[1,610,"*   Other initializer : 我们可以通过更灵活的参数注入来定义我们的初始化, 但只要我们用了自定义方法, 默认提供的 Memberwise Initializers就不再有效"]],[610,610],[707,707]]],[1559225046673,["he15his@he15hisMacBook15.local",[[-1,427,"#### 关于初始化的差别\n\n##### Struct的初始化\n\n*   Memberwise Initializers : Struct 会根据它所拥有的变量自带一个默认的初始化方法,我们将这个称谓Memberwise Initializers\n*   Default initializer: 通过给每一个属性默认值来完成初始化,但必须是每个属性都必须有默认值\n*   Other initializer : 我们可以通过更灵活的参数注入来定义我们的初始化, 但只要我们用了自定义方法, 默认提供的 Memberwise Initializers就不再有效\n"]],[426,707],[426,426]]],[1559225048356,["he15his@he15hisMacBook15.local",[[1,426,"#### 关于初始化的差别\n\n##### Struct的初始化\n\n*   Memberwise Initializers : Struct 会根据它所拥有的变量自带一个默认的初始化方法,我们将这个称谓Memberwise Initializers\n\n```\n//代码示例\nstruct PersonStruct{\n    var name : String\n    var age : Int\n}\nlet person_1 = PersonStruct(name: \"Swift\", age: 4)\n复制代码\n```\n\n*   Default initializer: 通过给每一个属性默认值来完成初始化,但必须是每个属性都必须有默认值\n\n```\n//示例代码\nstruct Point {\n    //第一种设置方法\n    var x: Double = 0.0\n    var y: Double = 0.0\n\n    //第二种设置方法\n    init(x: Double = 0.0, y: Double = 0.0) {\n        self.x = x\n        self.y = y\n    }\n}\nlet origin = Point()\n复制代码\n```\n\n*   Other initializer : 我们可以通过更灵活的参数注入来定义我们的初始化, 但只要我们用了自定义方法, 默认提供的 Memberwise Initializers就不再有效\n\n```\n//代码示例\nstruct PersonStruct{\n    var name : String\n    var age : Int\n\n    //自定义初始化\n    init(_ p : (name: String, age: Int)) {\n        self.name = p.0;\n        self.age = p.1;\n    }\n//此时 默认的Memberwise Initializers会失效,\n//let person_1 = PersonStruct(name: \"Swift\", age: 4)\nlet person_1 = PersonStruct((name: \"Swift\", age: 4))\n}\n复制代码\n```\n\n##### Class的初始化\n\nSwift不会为class生成默认的init方法，我们必须明确定义class类型的对象的创建过程, 它没有Struct类似的Memberwise Init\n\n```\n代码示例:\nclass Point2D {\n    var x: Double\n    var y: Double\n}\nlet person_2 = PersonClass(name: \"Swift\", age: 4)\n这个代码是无法通过编译的\n复制代码\n```\n\n*   designated init : 因为class没有Memberwise Init的说法,所以我们需要给class自定义一个初始化方法, 称为designated init\n\n```\n//一般情况下, 我们都会为Class designated一个init方法, 并且初始化它的所有属性\nclass Person {\n    var name : String\n    var age : Int\n    init(name :String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\nlet person_2 = Person(name: \"Swift\", age: 4)\n复制代码\n```\n\n*   convienience init : 便利化初始化,可以将参数以 Toupe / 合适的形式注入初始化方法,有更好的语义的表达, init方法用 convienience 关键字修饰\n\n```\n//示例代码\nclass Man {\n    var name : String\n    var age : Int\n    convenience init(at:(name:String, age:Int)){\n        self.init(name : at.name, age : at.age)\n    }\n\n    init(name:String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\nlet man = Man(at: (\"洛奇\", 18))\n复制代码\n```\n\n*   failable init: 并不是我们每次得到的参数都可以直接转换成 class 中的属性,有可能参数并不是我们想要的类型, 这个时候为了更好地保证程序的安全性,稳定性,这个时候 failable init 就出现了;需要用init?的形式来定义它;\n\n```\n//代码示例\nclass Woman {\n    var name : String\n    var age : Int\n\n   convenience init?(at:(String, String)){\n        guard  let age = Int(at.1) else { return nil }\n        self.init(name : at.0, age : age)\n    }\n\n    init(name:String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\nlet woman = Woman(at: (\"memng\", \"18\"))\n复制代码\n```\n\n*   two-phase init: 这是class对象针对继承所优化的初始化方法,通过two-phase init, 子类和基类的属性都可以正确初始化, 而这个初始化分为两个阶段, 所以称为两段式构造过程;\n\n第一阶段: 从子类到基类让每个类都自下而上的让每一个属性都有初始值 第二阶段: 所以有属性都有初始值之后，从基类到派生类，自上而下对类的每个属性进行进一步处理\n\n```\n//示例代码\nclass Point2d {\n    var x : Double\n    var y : Double\n\n    init(x: Double, y : Double)  {\n        self.x = x\n        self.y = y\n    }\n}\n\nlet point : Point2d = Point2d(x: 2, y: 3)\n\nclass Point3d : Point2d{\n    var z : Double\n\n    init(x: Double = 0, y: Double = 0, z: Double = 0) {\n\n        //第一步: 先保证自下而上的让每个属性有初始值, 且self.z的初始化必须在super.init调用前\n        self.z = z\n        super.init(x: x, y: y)\n        //第二步: 自上而下的对每个属性进行处理\n        self.initRound(x: x, y: y, z: z)\n    }\n    func initRound(x: Double, y: Double, z: Double) {\n        self.x = round(x)\n        self.y = round(y)\n        self.z = round(z)\n    }\n\n}\n复制代码\n```\n\n#### 关于正确理解值语义和引用语义,从而区分struct和class\n\n*   引用类型的常量的属性值是可以修改的,而值类型的常量属性是不可以修改的\n\n```\n//示例代码\nclass PointRef {\n    var x : Int\n    var y : Int\n    init(x : Int, y : Int) {\n        self.x = x\n        self.y = y\n    }\n}\nstruct PointValue{\n    var x : Int\n    var y : Int\n}\nlet pointClass = PointRef(x: 10, y: 10)\nlet pointStruct = PointValue(x: 12, y: 12)\n\n//pointStruct.y = 16 //值类型的常量的属性值是不可以修改的\npointClass.x = 12 //引用类型的常量的属性值是可以修改的\n\n引用类型默认是可以修改的, 因为引用类型关注的是对象本身, 而并非是引用的值,因此它的属性默认是可以修改其值的\n复制代码\n```\n\n*   值类型和引用类型在语义上的差别很大, 值类型的赋值只是简单的内存拷贝后,生成新的值, 而引用类型的赋值是内存地址的共同指向;\n\n```\n//代码示例: \nclass PointRef {\n    var x : Int\n    var y : Int\n\n    init(x : Int, y : Int) {\n        self.x = x\n        self.y = y\n    }\n}\nstruct PointValue{\n    var x : Int\n    var y : Int\n}\nlet pointClass = PointRef(x: 10, y: 10)\nlet pointStruct = PointValue(x: 12, y: 12)\n\nvar pointClass1 = pointClass\nvar pointStruct1 = pointStruct\n\n//修改 class1, class也一起被修改\npointClass1.x = 16\nprint(pointClass.x)\n\n//修改 V1的值, V的值并没有发生改变\npointStruct1.y = 20\nprint(pointStruct.y)\n\n值类型的赋值只是简单的内存拷贝, 而引用类型的赋值是内存地址的共同指向\n复制代码\n```\n\n#### 关于class的继承, 我们应该有一些探讨\n\n**探讨1** : 子类会继承它的基类的方法,那么对于init方法会继承吗? **答:** 派生类不会主动继承其基类的init方法\n\n```\n//示例代码\nclass Person {\n    var name : String\n    var age : Int\n    init(name :String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\nclass Developer : Person{\n\n   var proLaunage : String //不会 继承 基类的 init 方法\n\n   //但是如果给子类的所以属性都给一个默认初始化值, 那么子类将会继承基类的 init方法\n   //var progLaunage : String = \"Swift\"\n}\n//此时,如果我们编译代码, 是无法通过的, 这也就验证了 子类不会继承基类的 init方法\nlet iosDev = Developer(name: \"luoColumn\", age: 18)\n\n//详细解释:\n虽然当派生类没有定义任何designated init 方法时, 会从基类继承基类的 designnated init 方法,但由于即便继承了,也完不成其自有变量的初始化, 所以 派生类也就不会自动继承其基类的初始化方法\n复制代码\n```\n\n**探讨2:** 如果一个派生类定义了所有基类的designated init，那么它也将自动继承基类所有的convenience init 方法吗? **答:** 只要派生类拥有基类所有的designated init方法，他就会自动获得所有基类的convenience init方法\n\n```\n//代码示例\nclass Man {\n    var name : String\n    var age : Int\n    convenience init(at:(name:String, age:Int)){\n        self.init(name : at.name, age : at.age)\n    }\n\n    init(name:String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\n\nclass Teacher : Man{\n    var height : Double\n    init(name:String, age:Int, height:Double) {\n// 先初始化self.height，然后再调用super.init初始化基类的成员, 这是 两段式构造过程\n        self.height = height\n        super.init(name: name, age: age)\n    }\n    //重写\n    override init(name: String, age: Int) {\n        self.height = 175\n        super.init(name: name, age: age)\n    }\n}\n\n//只要 override init 了 基类的 designated init方法, 就会自动继承它的 convenience init 方法\nlet teacher_1 = Teacher(at: (\"memng\", 18))\n复制代码\n```\n\n**探讨3:** 永远也不要改写继承而来的方法的默认参数，因为它执行的是静态绑定的语义。\n\n> 在Swift里，继承而来的方法调用是在运行时动态派发的，Swift会在运行时动态选择一个对象真正要调用的方法。但是，方法的参数，出于性能的考虑，却是静态绑定的，编译器会根据调用方法的对象的类型，绑定函数的参数\n\n```\n//代码示例\nclass Human {\n var name : String\n    var age : Int\n    init(name :String, age:Int) {\n        self.name = name\n        self.age = age\n    }  \n    func nameSetting(name : String = \"Swift\") {\n\n    }\n}\nclass Kid : Human{\n    override func nameSetting(name: String = \"Java\") {\n       print(\"name is \\(name)\")\n    }\n}\nclass Younger : Human{\n    override func nameSetting(name: String = \"Python\") {\n        print(\"name is \\(name)\")\n    }\n}\n\n//当 kid 和 younger 分别是 他们具体的对象类型时, 修改默认值是没问题的\nlet kid = Kid()\nkid .nameSetting() //name is Java\nlet younger = Younger()\nyounger.nameSetting() //name is Python\n\n// 利用多态来动态选择调用方法时, 结果却都是调用了基类中的 nameSetting方法\nlet human_kid : Human = Kid()\nlet human_you : Human = Younger()\n\nhuman_kid.nameSetting() //name is Swift\nhuman_you.nameSetting() //name is Swift\n因此:\n永远也不要改写继承而来的方法的默认参数，因为它执行的是静态绑定的语义\n复制代码\n```\n\n#### 关于class 和 struct的使用场景\n\n1.  在整个工程中, 那些需要有明显的生命周期的, 我们在初始化或者销毁的时候需要有特定的操作的,在进行比较时我们不是很关注他们的属性是否相同,而更关注内存地址的场景,应该用class来表述; 例如: 文件句柄，通知中心，网络接口，数据库连接，view controller等\n\n2.  在整个工程中, 那些不需要生命周期的,在进行比较时我们不关注它的内存地址,只关注值是否相等的,在摧毁时并不需要完成特定操作的场景,应该使用struct来表述; 例如: 时间日期,字符串,数字,错误,URL,二进制数据,通知等;\n\n作者：PenName\n链接：https://juejin.im/post/5ad45b56f265da238926316a\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[426,426],[7676,7676]]],[1559225119028,[null,[[-1,56,"[结构体与类](https://juejin.im/post/5ad45b56f265da238926316a)\n\n##### Struct与Class的共性\n\n1.  定义属性以存储值\n2.  定义提供功能的方法\n3.  使用下标语法定义下标以提供对其值的访问\n4.  定义初始化程序以设置其初始状态\n5.  扩展到超出默认实现范围的功能\n6.  符合协议以提供某种标准功能\n\n##### Struct与Class的区别\n\n1.  Class 是引用类型, Struct是值类型\n2.  内存管理的方式不同, 结构体可以被直接持有及访问, 结构体不会被引用,只会被复制,而类的实例只能通过引用间接访问。\n3.  使用类,可以通过继承来共享代码,而结构体不能被继承\n"],[-1,424,"\n\n#### 关于初始化的差别\n\n##### Struct的初始化\n\n*   Memberwise Initializers : Struct 会根据它所拥有的变量自带一个默认的初始化方法,我们将这个称谓Memberwise Initializers\n\n```\n//代码示例\nstruct PersonStruct{\n    var name : String\n    var age : Int\n}\nlet person_1 = PersonStruct(name: \"Swift\", age: 4)\n复制代码\n```\n\n*   Default initializer: 通过给每一个属性默认值来完成初始化,但必须是每个属性都必须有默认值\n\n```\n//示例代码\nstruct Point {\n    //第一种设置方法\n    var x: Double = 0.0\n    var y: Double = 0.0\n\n    //第二种设置方法\n    init(x: Double = 0.0, y: Double = 0.0) {\n        self.x = x\n        self.y = y\n    }\n}\nlet origin = Point()\n复制代码\n```\n\n*   Other initializer : 我们可以通过更灵活的参数注入来定义我们的初始化, 但只要我们用了自定义方法, 默认提供的 Memberwise Initializers就不再有效\n\n```\n//代码示例\nstruct PersonStruct{\n    var name : String\n    var age : Int\n\n    //自定义初始化\n    init(_ p : (name: String, age: Int)) {\n        self.name = p.0;\n        self.age = p.1;\n    }\n//此时 默认的Memberwise Initializers会失效,\n//let person_1 = PersonStruct(name: \"Swift\", age: 4)\nlet person_1 = PersonStruct((name: \"Swift\", age: 4))\n}\n复制代码\n```\n\n##### Class的初始化\n\nSwift不会为class生成默认的init方法，我们必须明确定义class类型的对象的创建过程, 它没有Struct类似的Memberwise Init\n\n```\n代码示例:\nclass Point2D {\n    var x: Double\n    var y: Double\n}\nlet person_2 = PersonClass(name: \"Swift\", age: 4)\n这个代码是无法通过编译的\n复制代码\n```\n\n*   designated init : 因为class没有Memberwise Init的说法,所以我们需要给class自定义一个初始化方法, 称为designated init\n\n```\n//一般情况下, 我们都会为Class designated一个init方法, 并且初始化它的所有属性\nclass Person {\n    var name : String\n    var age : Int\n    init(name :String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\nlet person_2 = Person(name: \"Swift\", age: 4)\n复制代码\n```\n\n*   convienience init : 便利化初始化,可以将参数以 Toupe / 合适的形式注入初始化方法,有更好的语义的表达, init方法用 convienience 关键字修饰\n\n```\n//示例代码\nclass Man {\n    var name : String\n    var age : Int\n    convenience init(at:(name:String, age:Int)){\n        self.init(name : at.name, age : at.age)\n    }\n\n    init(name:String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\nlet man = Man(at: (\"洛奇\", 18))\n复制代码\n```\n\n*   failable init: 并不是我们每次得到的参数都可以直接转换成 class 中的属性,有可能参数并不是我们想要的类型, 这个时候为了更好地保证程序的安全性,稳定性,这个时候 failable init 就出现了;需要用init?的形式来定义它;\n\n```\n//代码示例\nclass Woman {\n    var name : String\n    var age : Int\n\n   convenience init?(at:(String, String)){\n        guard  let age = Int(at.1) else { return nil }\n        self.init(name : at.0, age : age)\n    }\n\n    init(name:String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\nlet woman = Woman(at: (\"memng\", \"18\"))\n复制代码\n```\n\n*   two-phase init: 这是class对象针对继承所优化的初始化方法,通过two-phase init, 子类和基类的属性都可以正确初始化, 而这个初始化分为两个阶段, 所以称为两段式构造过程;\n\n第一阶段: 从子类到基类让每个类都自下而上的让每一个属性都有初始值 第二阶段: 所以有属性都有初始值之后，从基类到派生类，自上而下对类的每个属性进行进一步处理\n\n```\n//示例代码\nclass Point2d {\n    var x : Double\n    var y : Double\n\n    init(x: Double, y : Double)  {\n        self.x = x\n        self.y = y\n    }\n}\n\nlet point : Point2d = Point2d(x: 2, y: 3)\n\nclass Point3d : Point2d{\n    var z : Double\n\n    init(x: Double = 0, y: Double = 0, z: Double = 0) {\n\n        //第一步: 先保证自下而上的让每个属性有初始值, 且self.z的初始化必须在super.init调用前\n        self.z = z\n        super.init(x: x, y: y)\n        //第二步: 自上而下的对每个属性进行处理\n        self.initRound(x: x, y: y, z: z)\n    }\n    func initRound(x: Double, y: Double, z: Double) {\n        self.x = round(x)\n        self.y = round(y)\n        self.z = round(z)\n    }\n\n}\n复制代码\n```\n\n#### 关于正确理解值语义和引用语义,从而区分struct和class\n\n*   引用类型的常量的属性值是可以修改的,而值类型的常量属性是不可以修改的\n\n```\n//示例代码\nclass PointRef {\n    var x : Int\n    var y : Int\n    init(x : Int, y : Int) {\n        self.x = x\n        self.y = y\n    }\n}\nstruct PointValue{\n    var x : Int\n    var y : Int\n}\nlet pointClass = PointRef(x: 10, y: 10)\nlet pointStruct = PointValue(x: 12, y: 12)\n\n//pointStruct.y = 16 //值类型的常量的属性值是不可以修改的\npointClass.x = 12 //引用类型的常量的属性值是可以修改的\n\n引用类型默认是可以修改的, 因为引用类型关注的是对象本身, 而并非是引用的值,因此它的属性默认是可以修改其值的\n复制代码\n```\n\n*   值类型和引用类型在语义上的差别很大, 值类型的赋值只是简单的内存拷贝后,生成新的值, 而引用类型的赋值是内存地址的共同指向;\n\n```\n//代码示例: \nclass PointRef {\n    var x : Int\n    var y : Int\n\n    init(x : Int, y : Int) {\n        self.x = x\n        self.y = y\n    }\n}\nstruct PointValue{\n    var x : Int\n    var y : Int\n}\nlet pointClass = PointRef(x: 10, y: 10)\nlet pointStruct = PointValue(x: 12, y: 12)\n\nvar pointClass1 = pointClass\nvar pointStruct1 = pointStruct\n\n//修改 class1, class也一起被修改\npointClass1.x = 16\nprint(pointClass.x)\n\n//修改 V1的值, V的值并没有发生改变\npointStruct1.y = 20\nprint(pointStruct.y)\n\n值类型的赋值只是简单的内存拷贝, 而引用类型的赋值是内存地址的共同指向\n复制代码\n```\n\n#### 关于class的继承, 我们应该有一些探讨\n\n**探讨1** : 子类会继承它的基类的方法,那么对于init方法会继承吗? **答:** 派生类不会主动继承其基类的init方法\n\n```\n//示例代码\nclass Person {\n    var name : String\n    var age : Int\n    init(name :String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\nclass Developer : Person{\n\n   var proLaunage : String //不会 继承 基类的 init 方法\n\n   //但是如果给子类的所以属性都给一个默认初始化值, 那么子类将会继承基类的 init方法\n   //var progLaunage : String = \"Swift\"\n}\n//此时,如果我们编译代码, 是无法通过的, 这也就验证了 子类不会继承基类的 init方法\nlet iosDev = Developer(name: \"luoColumn\", age: 18)\n\n//详细解释:\n虽然当派生类没有定义任何designated init 方法时, 会从基类继承基类的 designnated init 方法,但由于即便继承了,也完不成其自有变量的初始化, 所以 派生类也就不会自动继承其基类的初始化方法\n复制代码\n```\n\n**探讨2:** 如果一个派生类定义了所有基类的designated init，那么它也将自动继承基类所有的convenience init 方法吗? **答:** 只要派生类拥有基类所有的designated init方法，他就会自动获得所有基类的convenience init方法\n\n```\n//代码示例\nclass Man {\n    var name : String\n    var age : Int\n    convenience init(at:(name:String, age:Int)){\n        self.init(name : at.name, age : at.age)\n    }\n\n    init(name:String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\n\nclass Teacher : Man{\n    var height : Double\n    init(name:String, age:Int, height:Double) {\n// 先初始化self.height，然后再调用super.init初始化基类的成员, 这是 两段式构造过程\n        self.height = height\n        super.init(name: name, age: age)\n    }\n    //重写\n    override init(name: String, age: Int) {\n        self.height = 175\n        super.init(name: name, age: age)\n    }\n}\n\n//只要 override init 了 基类的 designated init方法, 就会自动继承它的 convenience init 方法\nlet teacher_1 = Teacher(at: (\"memng\", 18))\n复制代码\n```\n\n**探讨3:** 永远也不要改写继承而来的方法的默认参数，因为它执行的是静态绑定的语义。\n\n> 在Swift里，继承而来的方法调用是在运行时动态派发的，Swift会在运行时动态选择一个对象真正要调用的方法。但是，方法的参数，出于性能的考虑，却是静态绑定的，编译器会根据调用方法的对象的类型，绑定函数的参数\n\n```\n//代码示例\nclass Human {\n var name : String\n    var age : Int\n    init(name :String, age:Int) {\n        self.name = name\n        self.age = age\n    }  \n    func nameSetting(name : String = \"Swift\") {\n\n    }\n}\nclass Kid : Human{\n    override func nameSetting(name: String = \"Java\") {\n       print(\"name is \\(name)\")\n    }\n}\nclass Younger : Human{\n    override func nameSetting(name: String = \"Python\") {\n        print(\"name is \\(name)\")\n    }\n}\n\n//当 kid 和 younger 分别是 他们具体的对象类型时, 修改默认值是没问题的\nlet kid = Kid()\nkid .nameSetting() //name is Java\nlet younger = Younger()\nyounger.nameSetting() //name is Python\n\n// 利用多态来动态选择调用方法时, 结果却都是调用了基类中的 nameSetting方法\nlet human_kid : Human = Kid()\nlet human_you : Human = Younger()\n\nhuman_kid.nameSetting() //name is Swift\nhuman_you.nameSetting() //name is Swift\n因此:\n永远也不要改写继承而来的方法的默认参数，因为它执行的是静态绑定的语义\n复制代码\n```\n\n#### 关于class 和 struct的使用场景\n\n1.  在整个工程中, 那些需要有明显的生命周期的, 我们在初始化或者销毁的时候需要有特定的操作的,在进行比较时我们不是很关注他们的属性是否相同,而更关注内存地址的场景,应该用class来表述; 例如: 文件句柄，通知中心，网络接口，数据库连接，view controller等\n\n2.  在整个工程中, 那些不需要生命周期的,在进行比较时我们不关注它的内存地址,只关注值是否相等的,在摧毁时并不需要完成特定操作的场景,应该使用struct来表述; 例如: 时间日期,字符串,数字,错误,URL,二进制数据,通知等;\n\n作者：PenName\n链接：https://juejin.im/post/5ad45b56f265da238926316a\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n"]],[56,56],[424,424]]],[1559225119028,[null,[[1,56,"[结构体与类](https://juejin.im/post/5ad45b56f265da238926316a)\n\n##### Struct与Class的共性\n\n1.  定义属性以存储值\n2.  定义提供功能的方法\n3.  使用下标语法定义下标以提供对其值的访问\n4.  定义初始化程序以设置其初始状态\n5.  扩展到超出默认实现范围的功能\n6.  符合协议以提供某种标准功能\n\n##### Struct与Class的区别\n\n1.  Class 是引用类型, Struct是值类型\n2.  内存管理的方式不同, 结构体可以被直接持有及访问, 结构体不会被引用,只会被复制,而类的实例只能通过引用间接访问。\n3.  使用类,可以通过继承来共享代码,而结构体不能被继承\n"],[1,91,"\n\n#### 关于初始化的差别\n\n##### Struct的初始化\n\n*   Memberwise Initializers : Struct 会根据它所拥有的变量自带一个默认的初始化方法,我们将这个称谓Memberwise Initializers\n\n```\n//代码示例\nstruct PersonStruct{\n    var name : String\n    var age : Int\n}\nlet person_1 = PersonStruct(name: \"Swift\", age: 4)\n复制代码\n```\n\n*   Default initializer: 通过给每一个属性默认值来完成初始化,但必须是每个属性都必须有默认值\n\n```\n//示例代码\nstruct Point {\n    //第一种设置方法\n    var x: Double = 0.0\n    var y: Double = 0.0\n\n    //第二种设置方法\n    init(x: Double = 0.0, y: Double = 0.0) {\n        self.x = x\n        self.y = y\n    }\n}\nlet origin = Point()\n复制代码\n```\n\n*   Other initializer : 我们可以通过更灵活的参数注入来定义我们的初始化, 但只要我们用了自定义方法, 默认提供的 Memberwise Initializers就不再有效\n\n```\n//代码示例\nstruct PersonStruct{\n    var name : String\n    var age : Int\n\n    //自定义初始化\n    init(_ p : (name: String, age: Int)) {\n        self.name = p.0;\n        self.age = p.1;\n    }\n//此时 默认的Memberwise Initializers会失效,\n//let person_1 = PersonStruct(name: \"Swift\", age: 4)\nlet person_1 = PersonStruct((name: \"Swift\", age: 4))\n}\n复制代码\n```\n\n##### Class的初始化\n\nSwift不会为class生成默认的init方法，我们必须明确定义class类型的对象的创建过程, 它没有Struct类似的Memberwise Init\n\n```\n代码示例:\nclass Point2D {\n    var x: Double\n    var y: Double\n}\nlet person_2 = PersonClass(name: \"Swift\", age: 4)\n这个代码是无法通过编译的\n复制代码\n```\n\n*   designated init : 因为class没有Memberwise Init的说法,所以我们需要给class自定义一个初始化方法, 称为designated init\n\n```\n//一般情况下, 我们都会为Class designated一个init方法, 并且初始化它的所有属性\nclass Person {\n    var name : String\n    var age : Int\n    init(name :String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\nlet person_2 = Person(name: \"Swift\", age: 4)\n复制代码\n```\n\n*   convienience init : 便利化初始化,可以将参数以 Toupe / 合适的形式注入初始化方法,有更好的语义的表达, init方法用 convienience 关键字修饰\n\n```\n//示例代码\nclass Man {\n    var name : String\n    var age : Int\n    convenience init(at:(name:String, age:Int)){\n        self.init(name : at.name, age : at.age)\n    }\n\n    init(name:String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\nlet man = Man(at: (\"洛奇\", 18))\n复制代码\n```\n\n*   failable init: 并不是我们每次得到的参数都可以直接转换成 class 中的属性,有可能参数并不是我们想要的类型, 这个时候为了更好地保证程序的安全性,稳定性,这个时候 failable init 就出现了;需要用init?的形式来定义它;\n\n```\n//代码示例\nclass Woman {\n    var name : String\n    var age : Int\n\n   convenience init?(at:(String, String)){\n        guard  let age = Int(at.1) else { return nil }\n        self.init(name : at.0, age : age)\n    }\n\n    init(name:String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\nlet woman = Woman(at: (\"memng\", \"18\"))\n复制代码\n```\n\n*   two-phase init: 这是class对象针对继承所优化的初始化方法,通过two-phase init, 子类和基类的属性都可以正确初始化, 而这个初始化分为两个阶段, 所以称为两段式构造过程;\n\n第一阶段: 从子类到基类让每个类都自下而上的让每一个属性都有初始值 第二阶段: 所以有属性都有初始值之后，从基类到派生类，自上而下对类的每个属性进行进一步处理\n\n```\n//示例代码\nclass Point2d {\n    var x : Double\n    var y : Double\n\n    init(x: Double, y : Double)  {\n        self.x = x\n        self.y = y\n    }\n}\n\nlet point : Point2d = Point2d(x: 2, y: 3)\n\nclass Point3d : Point2d{\n    var z : Double\n\n    init(x: Double = 0, y: Double = 0, z: Double = 0) {\n\n        //第一步: 先保证自下而上的让每个属性有初始值, 且self.z的初始化必须在super.init调用前\n        self.z = z\n        super.init(x: x, y: y)\n        //第二步: 自上而下的对每个属性进行处理\n        self.initRound(x: x, y: y, z: z)\n    }\n    func initRound(x: Double, y: Double, z: Double) {\n        self.x = round(x)\n        self.y = round(y)\n        self.z = round(z)\n    }\n\n}\n复制代码\n```\n\n#### 关于正确理解值语义和引用语义,从而区分struct和class\n\n*   引用类型的常量的属性值是可以修改的,而值类型的常量属性是不可以修改的\n\n```\n//示例代码\nclass PointRef {\n    var x : Int\n    var y : Int\n    init(x : Int, y : Int) {\n        self.x = x\n        self.y = y\n    }\n}\nstruct PointValue{\n    var x : Int\n    var y : Int\n}\nlet pointClass = PointRef(x: 10, y: 10)\nlet pointStruct = PointValue(x: 12, y: 12)\n\n//pointStruct.y = 16 //值类型的常量的属性值是不可以修改的\npointClass.x = 12 //引用类型的常量的属性值是可以修改的\n\n引用类型默认是可以修改的, 因为引用类型关注的是对象本身, 而并非是引用的值,因此它的属性默认是可以修改其值的\n复制代码\n```\n\n*   值类型和引用类型在语义上的差别很大, 值类型的赋值只是简单的内存拷贝后,生成新的值, 而引用类型的赋值是内存地址的共同指向;\n\n```\n//代码示例: \nclass PointRef {\n    var x : Int\n    var y : Int\n\n    init(x : Int, y : Int) {\n        self.x = x\n        self.y = y\n    }\n}\nstruct PointValue{\n    var x : Int\n    var y : Int\n}\nlet pointClass = PointRef(x: 10, y: 10)\nlet pointStruct = PointValue(x: 12, y: 12)\n\nvar pointClass1 = pointClass\nvar pointStruct1 = pointStruct\n\n//修改 class1, class也一起被修改\npointClass1.x = 16\nprint(pointClass.x)\n\n//修改 V1的值, V的值并没有发生改变\npointStruct1.y = 20\nprint(pointStruct.y)\n\n值类型的赋值只是简单的内存拷贝, 而引用类型的赋值是内存地址的共同指向\n复制代码\n```\n\n#### 关于class的继承, 我们应该有一些探讨\n\n**探讨1** : 子类会继承它的基类的方法,那么对于init方法会继承吗? **答:** 派生类不会主动继承其基类的init方法\n\n```\n//示例代码\nclass Person {\n    var name : String\n    var age : Int\n    init(name :String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\nclass Developer : Person{\n\n   var proLaunage : String //不会 继承 基类的 init 方法\n\n   //但是如果给子类的所以属性都给一个默认初始化值, 那么子类将会继承基类的 init方法\n   //var progLaunage : String = \"Swift\"\n}\n//此时,如果我们编译代码, 是无法通过的, 这也就验证了 子类不会继承基类的 init方法\nlet iosDev = Developer(name: \"luoColumn\", age: 18)\n\n//详细解释:\n虽然当派生类没有定义任何designated init 方法时, 会从基类继承基类的 designnated init 方法,但由于即便继承了,也完不成其自有变量的初始化, 所以 派生类也就不会自动继承其基类的初始化方法\n复制代码\n```\n\n**探讨2:** 如果一个派生类定义了所有基类的designated init，那么它也将自动继承基类所有的convenience init 方法吗? **答:** 只要派生类拥有基类所有的designated init方法，他就会自动获得所有基类的convenience init方法\n\n```\n//代码示例\nclass Man {\n    var name : String\n    var age : Int\n    convenience init(at:(name:String, age:Int)){\n        self.init(name : at.name, age : at.age)\n    }\n\n    init(name:String, age:Int) {\n        self.name = name\n        self.age = age\n    }\n}\n\nclass Teacher : Man{\n    var height : Double\n    init(name:String, age:Int, height:Double) {\n// 先初始化self.height，然后再调用super.init初始化基类的成员, 这是 两段式构造过程\n        self.height = height\n        super.init(name: name, age: age)\n    }\n    //重写\n    override init(name: String, age: Int) {\n        self.height = 175\n        super.init(name: name, age: age)\n    }\n}\n\n//只要 override init 了 基类的 designated init方法, 就会自动继承它的 convenience init 方法\nlet teacher_1 = Teacher(at: (\"memng\", 18))\n复制代码\n```\n\n**探讨3:** 永远也不要改写继承而来的方法的默认参数，因为它执行的是静态绑定的语义。\n\n> 在Swift里，继承而来的方法调用是在运行时动态派发的，Swift会在运行时动态选择一个对象真正要调用的方法。但是，方法的参数，出于性能的考虑，却是静态绑定的，编译器会根据调用方法的对象的类型，绑定函数的参数\n\n```\n//代码示例\nclass Human {\n var name : String\n    var age : Int\n    init(name :String, age:Int) {\n        self.name = name\n        self.age = age\n    }  \n    func nameSetting(name : String = \"Swift\") {\n\n    }\n}\nclass Kid : Human{\n    override func nameSetting(name: String = \"Java\") {\n       print(\"name is \\(name)\")\n    }\n}\nclass Younger : Human{\n    override func nameSetting(name: String = \"Python\") {\n        print(\"name is \\(name)\")\n    }\n}\n\n//当 kid 和 younger 分别是 他们具体的对象类型时, 修改默认值是没问题的\nlet kid = Kid()\nkid .nameSetting() //name is Java\nlet younger = Younger()\nyounger.nameSetting() //name is Python\n\n// 利用多态来动态选择调用方法时, 结果却都是调用了基类中的 nameSetting方法\nlet human_kid : Human = Kid()\nlet human_you : Human = Younger()\n\nhuman_kid.nameSetting() //name is Swift\nhuman_you.nameSetting() //name is Swift\n因此:\n永远也不要改写继承而来的方法的默认参数，因为它执行的是静态绑定的语义\n复制代码\n```\n\n#### 关于class 和 struct的使用场景\n\n1.  在整个工程中, 那些需要有明显的生命周期的, 我们在初始化或者销毁的时候需要有特定的操作的,在进行比较时我们不是很关注他们的属性是否相同,而更关注内存地址的场景,应该用class来表述; 例如: 文件句柄，通知中心，网络接口，数据库连接，view controller等\n\n2.  在整个工程中, 那些不需要生命周期的,在进行比较时我们不关注它的内存地址,只关注值是否相等的,在摧毁时并不需要完成特定操作的场景,应该使用struct来表述; 例如: 时间日期,字符串,数字,错误,URL,二进制数据,通知等;\n\n作者：PenName\n链接：https://juejin.im/post/5ad45b56f265da238926316a\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n"]],[424,424],[56,56]]],[1559225065209,["he15his@he15hisMacBook15.local",[[-1,7573,"\n作者：PenName\n链接：https://juejin.im/post/5ad45b56f265da238926316a\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n"]],[7572,7676],[7572,7572]]]]]]}